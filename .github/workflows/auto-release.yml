name: 🚀 Auto Database Release

# Trigger when database files are pushed to feat/update branch
on:
  push:
    branches: [ feat/update ]
    paths:
      - 'database/**'

jobs:
  auto-release:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      repository-projects: write
    
    steps:
    - name: 🔍 Checkout feat/update branch
      uses: actions/checkout@v4
      with:
        ref: feat/update
        token: ${{ secrets.GITHUB_TOKEN }}
        fetch-depth: 0
        
    - name: 🐍 Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
        
    - name: 📦 Install Dependencies
      run: |
        python -m pip install --upgrade pip
        pip install cryptography
        # Install bc calculator for size calculations
        sudo apt-get update && sudo apt-get install -y bc zip
        
    - name: 🔍 Find Database File
      id: find-db
      run: |
        # Look for ZIP file (exclude macOS metadata files)
        ZIP_FILE=$(find database -name "*.zip" -type f | grep -v "__MACOSX" | grep -v "/\._" | head -1)
        
        if [ -z "$ZIP_FILE" ]; then
          echo "❌ No ZIP database file found in /database directory!"
          echo "Please upload a .zip file containing the .db file inside."
          exit 1
        fi
        
        echo "Found ZIP database: $ZIP_FILE"
        echo "db_file=$ZIP_FILE" >> $GITHUB_OUTPUT
        echo "db_name=$(basename $ZIP_FILE)" >> $GITHUB_OUTPUT
        
    - name: ✅ Validate Database
      run: |
        DB_FILE="${{ steps.find-db.outputs.db_file }}"
        
        echo "📊 Validating database: $DB_FILE"
        
        # Check file exists and size
        if [ ! -f "$DB_FILE" ]; then
          echo "❌ Database file not found: $DB_FILE"
          exit 1
        fi
        
        SIZE=$(stat -c%s "$DB_FILE" 2>/dev/null || stat -f%z "$DB_FILE" 2>/dev/null || echo "0")
        if [ "$SIZE" -eq 0 ]; then
          echo "❌ Database file is empty"
          exit 1
        fi
        
        echo "📊 Database size: $SIZE bytes ($(echo "scale=1; $SIZE / 1024 / 1024" | bc -l) MB)"
        echo "✅ Database validation passed!"
        
    - name: 🔐 Prepare Encrypted Release
      run: |
        DB_FILE="${{ steps.find-db.outputs.db_file }}"
        
        echo "🔐 Preparing encrypted database release"
        echo "Input ZIP file: $DB_FILE"
        
        # Ensure we have a 32-character encryption key
        if [ ${#ENCRYPTION_KEY} -ne 32 ]; then
          echo "⚠️  Encryption key is ${#ENCRYPTION_KEY} characters, truncating to 32"
          ENCRYPTION_KEY="${ENCRYPTION_KEY:0:32}"
        fi
        
        # Debug: Show key info (DO NOT log the full key in production!)
        echo "🔐 Key length: ${#ENCRYPTION_KEY} characters"
        echo "🔐 Key first 8 chars: '${ENCRYPTION_KEY:0:8}'"
        echo "🔐 Key last 8 chars: '${ENCRYPTION_KEY: -8}'"
        
        # TEMPORARY: Use hardcoded key to eliminate secret issues
        ENCRYPTION_KEY="+HehSIopDXwId20GMzXeancSkoKxaU1I"
        echo "🔐 Using hardcoded key for testing: first 8 chars '${ENCRYPTION_KEY:0:8}', last 8 chars '${ENCRYPTION_KEY: -8}'"
        
        # Get original ZIP file size
        ORIGINAL_SIZE=$(stat -c%s "$DB_FILE" 2>/dev/null || stat -f%z "$DB_FILE" 2>/dev/null)
        echo "📊 Original ZIP file size: $ORIGINAL_SIZE bytes ($(echo "scale=1; $ORIGINAL_SIZE / 1024 / 1024" | bc -l) MB)"
        
        # Show ZIP file contents
        echo "📦 ZIP file contents:"
        unzip -l "$DB_FILE"
        
        # Encrypt the ZIP file directly
        ENCRYPTED_FILE="SPJIN.db.zip"
        echo "🔐 Encrypting ZIP file to final release name: $ENCRYPTED_FILE"
        
        # Use OpenSSL with salt (matches our app's expected format)
        openssl enc -aes-256-cbc -salt -in "$DB_FILE" -out "$ENCRYPTED_FILE" -k "$ENCRYPTION_KEY"
        
        if [ ! -f "$ENCRYPTED_FILE" ]; then
          echo "❌ Failed to encrypt ZIP file"
          exit 1
        fi
        
        ENCRYPTED_SIZE=$(stat -c%s "$ENCRYPTED_FILE" 2>/dev/null || stat -f%z "$ENCRYPTED_FILE" 2>/dev/null)
        ENCRYPTION_OVERHEAD=$(echo "scale=1; (($ENCRYPTED_SIZE - $ORIGINAL_SIZE) * 100) / $ORIGINAL_SIZE" | bc -l)
        
        echo "📊 Final encrypted size: $ENCRYPTED_SIZE bytes ($(echo "scale=1; $ENCRYPTED_SIZE / 1024 / 1024" | bc -l) MB)"
        echo "📊 Encryption overhead: ${ENCRYPTION_OVERHEAD}%"
        
        # Store values for later steps
        echo "ORIGINAL_SIZE=$ORIGINAL_SIZE" >> $GITHUB_ENV
        echo "ENCRYPTED_SIZE=$ENCRYPTED_SIZE" >> $GITHUB_ENV
        echo "ENCRYPTION_OVERHEAD=$ENCRYPTION_OVERHEAD" >> $GITHUB_ENV
        echo "RELEASE_FILE=$ENCRYPTED_FILE" >> $GITHUB_ENV
        
        echo "✅ ZIP file encrypted successfully - final release file: $ENCRYPTED_FILE"
      env:
        ENCRYPTION_KEY: ${{ secrets.DB_ENCRYPTION_KEY }}
        
    - name: 📊 Calculate New Version
      id: version
      run: |
        # Get the latest release version
        LATEST_VERSION=$(gh release list --limit 1 --json tagName --jq '.[0].tagName' 2>/dev/null || echo "v0.0.0")
        echo "Latest version: $LATEST_VERSION"
        
        # Parse and increment major version
        if [[ $LATEST_VERSION =~ v([0-9]+)\.([0-9]+)\.([0-9]+) ]]; then
          MAJOR=${BASH_REMATCH[1]}
          NEW_VERSION="v$((MAJOR + 1)).0.0"
        else
          NEW_VERSION="v1.0.0"
        fi
        
        echo "New version: $NEW_VERSION"
        echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        
    - name: 🔄 Switch to main branch and update
      run: |
        # Store the encrypted file temporarily BEFORE switching branches
        TEMP_FILE="/tmp/encrypted_database_$(date +%s).zip"
        echo "📁 Storing encrypted file temporarily: $TEMP_FILE"
        cp "$RELEASE_FILE" "$TEMP_FILE"
        
        # Verify temp file was created
        if [ ! -f "$TEMP_FILE" ]; then
          echo "❌ Failed to create temporary file"
          exit 1
        fi
        
        echo "📊 Temp file size: $(stat -c%s "$TEMP_FILE" 2>/dev/null || stat -f%z "$TEMP_FILE" 2>/dev/null) bytes"
        
        # Configure git
        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"
        
        # Reset any changes to the current branch before switching
        echo "🔄 Resetting changes in feat/update branch"
        git checkout -- .
        git clean -fd
        
        # Switch to main branch
        echo "🔄 Switching to main branch"
        git fetch origin main
        git checkout main
        
        # Create database directory if it doesn't exist
        mkdir -p database
        
        # Copy the encrypted database to main branch
        TARGET_FILE="database/SPJIN.db.zip"
        cp "$TEMP_FILE" "$TARGET_FILE"
        echo "📁 Copied encrypted file to: $TARGET_FILE"
        
        # Verify the file was copied successfully
        if [ ! -f "$TARGET_FILE" ]; then
          echo "❌ Failed to copy file to main branch"
          exit 1
        fi
        
        echo "📊 Final file size in main: $(stat -c%s "$TARGET_FILE" 2>/dev/null || stat -f%z "$TARGET_FILE" 2>/dev/null) bytes"
        
        # Commit the encrypted database
        git add "$TARGET_FILE"
        git commit -m "🔐 Update encrypted database to ${{ steps.version.outputs.version }}"
        
        # Push using token
        git push https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git main
        
        # Copy the encrypted file back to current directory for release
        cp "$TARGET_FILE" "$RELEASE_FILE"
        echo "📁 Copied file back for release: $RELEASE_FILE"
        
        # Clean up temp file
        rm -f "$TEMP_FILE"
        echo "🗑️ Cleaned up temporary file"
        
    - name: 🚀 Create Release
      run: |
        VERSION="${{ steps.version.outputs.version }}"
        
        # Verify the release file exists
        if [ ! -f "$RELEASE_FILE" ]; then
          echo "❌ Release file not found: $RELEASE_FILE"
          echo "Current directory contents:"
          ls -la
          exit 1
        fi
        
        echo "📦 Preparing to release file: $RELEASE_FILE"
        echo "📊 File size: $(stat -c%s "$RELEASE_FILE" 2>/dev/null || stat -f%z "$RELEASE_FILE" 2>/dev/null) bytes"
        
        # Create comprehensive release notes
        echo "## 🗄️ Database Update" > release_notes.md
        echo "" >> release_notes.md
        echo "Database has been updated with new content using the secure zip-then-encrypt workflow." >> release_notes.md
        echo "" >> release_notes.md
        echo "## 📊 Database Information" >> release_notes.md
        echo "- **Version**: $VERSION" >> release_notes.md
        echo "- **Updated**: $(date -u '+%Y-%m-%d %H:%M:%S UTC')" >> release_notes.md
        echo "- **Original ZIP size**: $(echo "scale=1; $ORIGINAL_SIZE / 1024 / 1024" | bc -l) MB" >> release_notes.md
        echo "- **Final encrypted size**: $(echo "scale=1; $ENCRYPTED_SIZE / 1024 / 1024" | bc -l) MB" >> release_notes.md
        echo "- **Encryption overhead**: ${ENCRYPTION_OVERHEAD}%" >> release_notes.md
        
        # Create release with the encrypted ZIP file
        gh release create "$VERSION" \
          --title "🗄️ Database $VERSION" \
          --notes-file release_notes.md \
          --latest \
          "$RELEASE_FILE"
        
        echo "🎉 Release created: $VERSION"
        echo "📦 File uploaded: SPJIN.db.zip"
        echo "📊 Download size: $(echo "scale=1; $ENCRYPTED_SIZE / 1024 / 1024" | bc -l) MB"
        echo "✅ Mobile app should download: SPJIN.db.zip"
        echo ""
        echo "🔄 Workflow Summary:"
        echo "  Pre-compressed ZIP → Encrypt → Distribute as SPJIN.db.zip"
        echo "  $(echo "scale=1; $ORIGINAL_SIZE / 1024 / 1024" | bc -l)MB → $(echo "scale=1; $ENCRYPTED_SIZE / 1024 / 1024" | bc -l)MB → Release"
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        
    - name: 🗑️ Delete feat/update branch
      run: |
        echo "🗑️ Deleting feat/update branch"
        git push origin --delete feat/update
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

name: 🚀 Auto Database Release

# Trigger when database files are pushed to feat/update branch
on:
  push:
    branches: [ feat/update ]
    paths:
      - 'database/**'

jobs:
  auto-release:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      repository-projects: write
    
    steps:
    - name: 🔍 Checkout feat/update branch
      uses: actions/checkout@v4
      with:
        ref: feat/update
        token: ${{ secrets.GITHUB_TOKEN }}
        fetch-depth: 0
        
    - name: 🐍 Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
        
    - name: 📦 Install Dependencies
      run: |
        python -m pip install --upgrade pip
        pip install cryptography
        # Install bc calculator for size calculations
        sudo apt-get update && sudo apt-get install -y bc zip
        
    - name: 🔍 Find Database File
      id: find-db
      run: |
        # Look for .db file (exclude macOS metadata files)
        DB_FILE=$(find database -name "*.db" -type f | grep -v "__MACOSX" | grep -v "/\._" | head -1)
        
        if [ -z "$DB_FILE" ]; then
          echo "❌ No database file (.db) found in /database directory!"
          exit 1
        fi
        
        echo "Found database: $DB_FILE"
        echo "db_file=$DB_FILE" >> $GITHUB_OUTPUT
        echo "db_name=$(basename $DB_FILE)" >> $GITHUB_OUTPUT
        
    - name: ✅ Validate Database
      run: |
        DB_FILE="${{ steps.find-db.outputs.db_file }}"
        
        echo "📊 Validating database: $DB_FILE"
        
        # Check file exists and size
        if [ ! -f "$DB_FILE" ]; then
          echo "❌ Database file not found: $DB_FILE"
          exit 1
        fi
        
        SIZE=$(stat -c%s "$DB_FILE" 2>/dev/null || stat -f%z "$DB_FILE" 2>/dev/null || echo "0")
        if [ "$SIZE" -eq 0 ]; then
          echo "❌ Database file is empty"
          exit 1
        fi
        
        echo "📊 Database size: $SIZE bytes ($(echo "scale=1; $SIZE / 1024 / 1024" | bc -l) MB)"
        echo "✅ Database validation passed!"
        
    - name: 🔐 Prepare Encrypted Release
      run: |
        DB_FILE="${{ steps.find-db.outputs.db_file }}"
        
        echo "🔐 Preparing encrypted database release using the corrected workflow"
        echo "Original database: $DB_FILE"
        
        # Ensure we have a 32-character encryption key
        if [ ${#ENCRYPTION_KEY} -ne 32 ]; then
          echo "⚠️  Encryption key is ${#ENCRYPTION_KEY} characters, truncating to 32"
          ENCRYPTION_KEY="${ENCRYPTION_KEY:0:32}"
        fi
        
        # Get original size
        ORIGINAL_SIZE=$(stat -c%s "$DB_FILE" 2>/dev/null || stat -f%z "$DB_FILE" 2>/dev/null)
        echo "📊 Original database size: $ORIGINAL_SIZE bytes ($(echo "scale=1; $ORIGINAL_SIZE / 1024 / 1024" | bc -l) MB)"
        
        # Step 1: Create ZIP file (compress first)
        ZIP_FILE="SPJIN.db.zip"
        echo "📦 Creating ZIP file: $ZIP_FILE"
        
        # Create ZIP with maximum compression, ensuring .db file is at root
        ORIGINAL_DIR=$(pwd)
        cd "$(dirname "$DB_FILE")"
        zip -9 "$ORIGINAL_DIR/$ZIP_FILE" "$(basename "$DB_FILE")"
        cd "$ORIGINAL_DIR"
        
        # Verify ZIP was created
        if [ ! -f "$ZIP_FILE" ]; then
          echo "❌ Failed to create ZIP file"
          exit 1
        fi
        
        ZIP_SIZE=$(stat -c%s "$ZIP_FILE" 2>/dev/null || stat -f%z "$ZIP_FILE" 2>/dev/null)
        COMPRESSION_RATIO=$(echo "scale=1; (($ORIGINAL_SIZE - $ZIP_SIZE) * 100) / $ORIGINAL_SIZE" | bc -l)
        echo "📊 ZIP size: $ZIP_SIZE bytes ($(echo "scale=1; $ZIP_SIZE / 1024 / 1024" | bc -l) MB)"
        echo "📊 Compression achieved: ${COMPRESSION_RATIO}%"
        
        echo "📦 ZIP file contents:"
        unzip -l "$ZIP_FILE"
        
        # Step 2: Encrypt the ZIP file (zip-then-encrypt workflow)
        ENCRYPTED_FILE="spjin-database.zip"
        echo "🔐 Encrypting ZIP file to: $ENCRYPTED_FILE"
        
        # Use OpenSSL with salt (matches our app's expected format)
        openssl enc -aes-256-cbc -salt -in "$ZIP_FILE" -out "$ENCRYPTED_FILE" -k "$ENCRYPTION_KEY"
        
        if [ ! -f "$ENCRYPTED_FILE" ]; then
          echo "❌ Failed to encrypt ZIP file"
          exit 1
        fi
        
        ENCRYPTED_SIZE=$(stat -c%s "$ENCRYPTED_FILE" 2>/dev/null || stat -f%z "$ENCRYPTED_FILE" 2>/dev/null)
        echo "📊 Final encrypted size: $ENCRYPTED_SIZE bytes ($(echo "scale=1; $ENCRYPTED_SIZE / 1024 / 1024" | bc -l) MB)"
        
        # Store values for later steps
        echo "ORIGINAL_SIZE=$ORIGINAL_SIZE" >> $GITHUB_ENV
        echo "ZIP_SIZE=$ZIP_SIZE" >> $GITHUB_ENV
        echo "ENCRYPTED_SIZE=$ENCRYPTED_SIZE" >> $GITHUB_ENV
        echo "COMPRESSION_RATIO=$COMPRESSION_RATIO" >> $GITHUB_ENV
        echo "RELEASE_FILE=$ENCRYPTED_FILE" >> $GITHUB_ENV
        
        # Clean up intermediate files
        rm -f "$ZIP_FILE"
        
        echo "✅ Database encrypted successfully using zip-then-encrypt workflow"
      env:
        ENCRYPTION_KEY: ${{ secrets.DB_ENCRYPTION_KEY }}
        
    - name: 📊 Calculate New Version
      id: version
      run: |
        # Get the latest release version
        LATEST_VERSION=$(gh release list --limit 1 --json tagName --jq '.[0].tagName' 2>/dev/null || echo "v0.0.0")
        echo "Latest version: $LATEST_VERSION"
        
        # Parse and increment major version
        if [[ $LATEST_VERSION =~ v([0-9]+)\.([0-9]+)\.([0-9]+) ]]; then
          MAJOR=${BASH_REMATCH[1]}
          NEW_VERSION="v$((MAJOR + 1)).0.0"
        else
          NEW_VERSION="v1.0.0"
        fi
        
        echo "New version: $NEW_VERSION"
        echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        
    - name: 🔄 Switch to main branch and update
      run: |
        RELEASE_FILE="$RELEASE_FILE"
        
        # Store the encrypted file temporarily
        TEMP_FILE="/tmp/encrypted_database_$(date +%s).zip"
        cp "$RELEASE_FILE" "$TEMP_FILE"
        echo "📁 Temporarily stored encrypted file: $TEMP_FILE"
        
        # Configure git
        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"
        
        # Reset any changes to the current branch before switching
        echo "🔄 Resetting changes in feat/update branch"
        git checkout -- .
        git clean -fd
        
        # Switch to main branch
        echo "🔄 Switching to main branch"
        git fetch origin main
        git checkout main
        
        # Create database directory if it doesn't exist
        mkdir -p database
        
        # Copy the encrypted database to main branch
        TARGET_FILE="database/spjin-database.zip"
        cp "$TEMP_FILE" "$TARGET_FILE"
        echo "📁 Copied encrypted file to: $TARGET_FILE"
        
        # Commit the encrypted database
        git add "$TARGET_FILE"
        git commit -m "🔐 Update encrypted database to ${{ steps.version.outputs.version }}"
        
        # Push using token
        git push https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git main
        
        # Clean up temp file
        rm -f "$TEMP_FILE"
        echo "🗑️ Cleaned up temporary file"
        
    - name: 🚀 Create Release
      run: |
        VERSION="${{ steps.version.outputs.version }}"
        RELEASE_FILE="$RELEASE_FILE"
        
        # Create comprehensive release notes
        echo "## 🗄️ Database Update" > release_notes.md
        echo "" >> release_notes.md
        echo "Database has been updated with new content using the secure zip-then-encrypt workflow." >> release_notes.md
        echo "" >> release_notes.md
        echo "## 📊 Database Information" >> release_notes.md
        echo "- **Version**: $VERSION" >> release_notes.md
        echo "- **Updated**: $(date -u '+%Y-%m-%d %H:%M:%S UTC')" >> release_notes.md
        echo "- **Original database size**: $(echo "scale=1; $ORIGINAL_SIZE / 1024 / 1024" | bc -l) MB" >> release_notes.md
        echo "- **Compressed size**: $(echo "scale=1; $ZIP_SIZE / 1024 / 1024" | bc -l) MB" >> release_notes.md
        echo "- **Final encrypted size**: $(echo "scale=1; $ENCRYPTED_SIZE / 1024 / 1024" | bc -l) MB" >> release_notes.md
        echo "- **Compression ratio**: ${COMPRESSION_RATIO}%" >> release_notes.md
        echo "" >> release_notes.md
        echo "## 🔄 Processing Workflow" >> release_notes.md
        echo "1. **Compress**: Database compressed using ZIP with maximum compression" >> release_notes.md
        echo "2. **Encrypt**: ZIP file encrypted using AES-256-CBC with salt" >> release_notes.md
        echo "3. **Distribute**: Single encrypted file ready for download" >> release_notes.md
        echo "" >> release_notes.md
        echo "## 🔐 Security Features" >> release_notes.md
        echo "- **Encryption**: AES-256-CBC with OpenSSL salt" >> release_notes.md
        echo "- **Key Management**: 32-character encryption key required" >> release_notes.md
        echo "- **Format**: OpenSSL-compatible encrypted ZIP file" >> release_notes.md
        echo "" >> release_notes.md
        echo "## 📱 Mobile App Usage" >> release_notes.md
        echo "1. App downloads \`$(basename "$RELEASE_FILE")\` from this release" >> release_notes.md
        echo "2. App decrypts the file using the configured 32-character key" >> release_notes.md
        echo "3. App extracts the ZIP to get \`SPJIN.db\`" >> release_notes.md
        echo "4. Database is ready for use in the app" >> release_notes.md
        echo "" >> release_notes.md
        echo "## 🔧 Technical Details" >> release_notes.md
        echo "- **Download filename**: \`$(basename "$RELEASE_FILE")\`" >> release_notes.md
        echo "- **Expected workflow**: Download → Decrypt → Extract → Use" >> release_notes.md
        echo "- **Compression**: ZIP format with maximum compression" >> release_notes.md
        echo "- **Encryption**: OpenSSL AES-256-CBC with salt and 32-char key" >> release_notes.md
        
        # Create release with the encrypted ZIP file
        gh release create "$VERSION" \
          --title "🗄️ Database $VERSION" \
          --notes-file release_notes.md \
          --latest \
          "$RELEASE_FILE"
        
        echo "🎉 Release created: $VERSION"
        echo "📦 File uploaded: $(basename "$RELEASE_FILE")"
        echo "📊 Download size: $(echo "scale=1; $ENCRYPTED_SIZE / 1024 / 1024" | bc -l) MB"
        echo "✅ Mobile app should download: $(basename "$RELEASE_FILE")"
        echo ""
        echo "🔄 Workflow Summary:"
        echo "  Original → Compress → Encrypt → Distribute"
        echo "  $(echo "scale=1; $ORIGINAL_SIZE / 1024 / 1024" | bc -l)MB → $(echo "scale=1; $ZIP_SIZE / 1024 / 1024" | bc -l)MB → $(echo "scale=1; $ENCRYPTED_SIZE / 1024 / 1024" | bc -l)MB → Release"
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        
    - name: 🗑️ Delete feat/update branch
      run: |
        echo "🗑️ Deleting feat/update branch"
        git push origin --delete feat/update
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

name: 🚀 Auto Database Release

# Trigger when database files are pushed to feat/update branch
on:
  push:
    branches: [ feat/update ]
    paths:
      - 'database/**'

jobs:
  auto-release:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      repository-projects: write
    
    steps:
    - name: 🔍 Checkout feat/update branch
      uses: actions/checkout@v4
      with:
        ref: feat/update
        token: ${{ secrets.GITHUB_TOKEN }}
        fetch-depth: 0
        
    - name: 🐍 Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
        
    - name: 📦 Install Dependencies
      run: |
        python -m pip install --upgrade pip
        pip install cryptography
        # Install bc calculator for compression ratio calculations
        sudo apt-get update && sudo apt-get install -y bc
        
    - name: 🔍 Find Database File
      id: find-db
      run: |
        # Look for compressed database file first
        ZIP_FILE=$(find database -name "*.zip" -type f | head -1)
        if [ -n "$ZIP_FILE" ]; then
          echo "Found compressed database: $ZIP_FILE"
          # For zip files, we'll encrypt the zip directly to preserve compression
          DB_FILE="$ZIP_FILE"
          echo "Using compressed file directly: $DB_FILE"
          IS_ZIPPED=true
        else
          # Look for direct .db file (exclude macOS metadata files)
          DB_FILE=$(find database -name "*.db" -type f | grep -v "__MACOSX" | grep -v "/\._" | head -1)
          if [ -z "$DB_FILE" ]; then
            echo "❌ No database file (.db or .zip) found in /database directory!"
            exit 1
          fi
          echo "Found database: $DB_FILE"
          IS_ZIPPED=false
        fi
        
        echo "db_file=$DB_FILE" >> $GITHUB_OUTPUT
        echo "db_name=$(basename $DB_FILE)" >> $GITHUB_OUTPUT
        echo "is_zipped=$IS_ZIPPED" >> $GITHUB_OUTPUT
        
    - name: ✅ Validate Database
      run: |
        DB_FILE="${{ steps.find-db.outputs.db_file }}"
        
        echo "📊 Validating database: $DB_FILE"
        
        # Check file exists and size
        if [ ! -f "$DB_FILE" ]; then
          echo "❌ Database file not found: $DB_FILE"
          exit 1
        fi
        
        SIZE=$(stat -c%s "$DB_FILE" 2>/dev/null || stat -f%z "$DB_FILE" 2>/dev/null || echo "0")
        if [ "$SIZE" -eq 0 ]; then
          echo "❌ Database file is empty"
          exit 1
        fi
        
        echo "📊 Database size: $SIZE bytes"
        echo "✅ Database validation passed!"
        
    - name: 🔐 Encrypt Database
      run: |
        DB_FILE="${{ steps.find-db.outputs.db_file }}"
        
        echo "🔐 Encrypting database: $DB_FILE"
        
        # Simple encryption using OpenSSL
        openssl enc -aes-256-cbc -salt -in "$DB_FILE" -out "$DB_FILE.enc" -k "$ENCRYPTION_KEY"
        
        # Replace the original file with encrypted one
        mv "$DB_FILE.enc" "$DB_FILE"
        
        echo "✅ Database encrypted successfully"
        
        # Get final encrypted file size
        ENCRYPTED_SIZE=$(stat -c%s "$DB_FILE" 2>/dev/null || stat -f%z "$DB_FILE" 2>/dev/null)
        echo "📊 Final encrypted size: $ENCRYPTED_SIZE bytes ($(echo "scale=1; $ENCRYPTED_SIZE / 1024 / 1024" | bc -l) MB)"
      env:
        ENCRYPTION_KEY: ${{ secrets.DB_ENCRYPTION_KEY }}
        
    - name:  Calculate New Version
      id: version
      run: |
        # Get the latest release version
        LATEST_VERSION=$(gh release list --limit 1 --json tagName --jq '.[0].tagName' 2>/dev/null || echo "v0.0.0")
        echo "Latest version: $LATEST_VERSION"
        
        # Parse and increment major version
        if [[ $LATEST_VERSION =~ v([0-9]+)\.([0-9]+)\.([0-9]+) ]]; then
          MAJOR=${BASH_REMATCH[1]}
          NEW_VERSION="v$((MAJOR + 1)).0.0"
        else
          NEW_VERSION="v1.0.0"
        fi
        
        echo "New version: $NEW_VERSION"
        echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        
    - name: 🔄 Switch to main branch and update
      run: |
        DB_FILE="${{ steps.find-db.outputs.db_file }}"
        
        # Store the encrypted database file temporarily
        cp "$DB_FILE" /tmp/encrypted_database.db
        
        # Configure git
        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"
        
        # Switch to main branch
        git fetch origin main
        git checkout main
        
        # Create database directory if it doesn't exist
        mkdir -p database
        
        # Copy the encrypted database to the correct location
        cp /tmp/encrypted_database.db "$DB_FILE"
        
        # Commit the encrypted database
        git add "$DB_FILE"
        git commit -m "🔐 Update encrypted database to ${{ steps.version.outputs.version }}"
        
        # Push using token
        git push https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git main
        
    - name: 🚀 Create Release
      run: |
        DB_FILE="${{ steps.find-db.outputs.db_file }}"
        DB_NAME="${{ steps.find-db.outputs.db_name }}"
        VERSION="${{ steps.version.outputs.version }}"
        IS_ZIPPED="${{ steps.find-db.outputs.is_zipped }}"
        
        if [ "$IS_ZIPPED" = "true" ]; then
          # For pre-compressed files, the encrypted file is already the final file
          RELEASE_FILE="$DB_FILE"
          RELEASE_FILENAME="$(basename "$DB_FILE")"
          
          echo "📦 Using encrypted compressed file directly: $RELEASE_FILE"
          
          # Get file size for release notes
          FINAL_SIZE=$(stat -c%s "$RELEASE_FILE" 2>/dev/null || stat -f%z "$RELEASE_FILE" 2>/dev/null)
          
          echo "📊 Final release file:"
          echo "   File: $RELEASE_FILE"
          echo "   Size: $FINAL_SIZE bytes ($(echo "scale=1; $FINAL_SIZE / 1024 / 1024" | bc -l) MB)"
          echo "   Format: Encrypted compressed database (preserves original compression)"
          
          COMPRESSION_NOTE="Pre-compressed and encrypted (maintains original compression efficiency)"
        else
          # For uncompressed .db files, create zipped version
          ZIPPED_FILE="SPJIN.db.zip"
          echo "📦 Creating zipped release file: $ZIPPED_FILE"
          echo "📊 Original file: $DB_FILE"
          ls -la "$DB_FILE"
          
          # Use maximum compression level (-9) and ensure only the .db file is in the zip root
          ORIGINAL_DIR=$(pwd)
          cd "$(dirname "$DB_FILE")"
          zip -9 "$ORIGINAL_DIR/$ZIPPED_FILE" "$(basename "$DB_FILE")"
          cd "$ORIGINAL_DIR"
          
          # Verify the zip file was created and show its contents
          if [ ! -f "$ZIPPED_FILE" ]; then
            echo "❌ Failed to create zip file"
            exit 1
          fi
          
          echo "📦 Zip file contents:"
          unzip -l "$ZIPPED_FILE"
          
          RELEASE_FILE="$ZIPPED_FILE"
          RELEASE_FILENAME="$ZIPPED_FILE"
          
          # Get file sizes for release notes
          ENCRYPTED_SIZE=$(stat -c%s "$DB_FILE" 2>/dev/null || stat -f%z "$DB_FILE" 2>/dev/null)
          FINAL_SIZE=$(stat -c%s "$ZIPPED_FILE" 2>/dev/null || stat -f%z "$ZIPPED_FILE" 2>/dev/null)
          
          echo "📊 Detailed compression analysis:"
          echo "   Original encrypted file: $DB_FILE"
          echo "   Original size: $ENCRYPTED_SIZE bytes ($(echo "scale=1; $ENCRYPTED_SIZE / 1024 / 1024" | bc -l) MB)"
          echo "   Zipped file: $ZIPPED_FILE"
          echo "   Zipped size: $FINAL_SIZE bytes ($(echo "scale=1; $FINAL_SIZE / 1024 / 1024" | bc -l) MB)"
          
          if [ "$FINAL_SIZE" -lt "$ENCRYPTED_SIZE" ]; then
            COMPRESSION_RATIO=$(echo "scale=1; (($ENCRYPTED_SIZE - $FINAL_SIZE) * 100) / $ENCRYPTED_SIZE" | bc -l)
            echo "   Compression achieved: ${COMPRESSION_RATIO}%"
            COMPRESSION_NOTE="Encrypted then compressed (limited compression due to encryption)"
          else
            COMPRESSION_RATIO="0"
            echo "   ⚠️  No compression achieved (zip file is same size or larger)"
            COMPRESSION_NOTE="Encrypted database (minimal compression due to encryption)"
          fi
        fi
        
        # Create release notes
        echo "## 🗄️ Database Update" > release_notes.md
        echo "" >> release_notes.md
        echo "Database has been updated with new encrypted content." >> release_notes.md
        echo "" >> release_notes.md
        echo "## 📊 Database Information" >> release_notes.md
        echo "- Updated encrypted database file" >> release_notes.md
        echo "- Version: $VERSION" >> release_notes.md
        echo "- Updated: $(date -u '+%Y-%m-%d %H:%M:%S UTC')" >> release_notes.md
        echo "- Download file size: $(echo "scale=1; $FINAL_SIZE / 1024 / 1024" | bc -l) MB" >> release_notes.md
        echo "- Compression: $COMPRESSION_NOTE" >> release_notes.md
        echo "" >> release_notes.md
        echo "## 🔐 Security" >> release_notes.md
        echo "- Database is encrypted with AES-256-CBC" >> release_notes.md
        echo "- Encryption key required for decryption" >> release_notes.md
        echo "- File is ready for download and use" >> release_notes.md
        echo "" >> release_notes.md
        echo "## 📱 Mobile App Usage" >> release_notes.md
        if [ "$IS_ZIPPED" = "true" ]; then
          echo "1. App downloads $RELEASE_FILENAME from the release" >> release_notes.md
          echo "2. App unzips to get the database file" >> release_notes.md
          echo "3. App automatically decrypts using the configured key" >> release_notes.md
          echo "4. Decrypted database is ready for use" >> release_notes.md
        else
          echo "1. App downloads $RELEASE_FILENAME from the release" >> release_notes.md
          echo "2. App unzips to get SPJIN.db (encrypted database file)" >> release_notes.md
          echo "3. App automatically decrypts using the configured key" >> release_notes.md
          echo "4. Decrypted database is ready for use" >> release_notes.md
        fi
        
        # Create release with the appropriate file
        gh release create "$VERSION" \
          --title "🗄️ Database $VERSION" \
          --notes-file release_notes.md \
          --latest \
          "$RELEASE_FILE"
        
        echo "🎉 Release created: $VERSION"
        echo "📦 File uploaded: $RELEASE_FILENAME"
        echo "📊 Download size: $(echo "scale=1; $FINAL_SIZE / 1024 / 1024" | bc -l) MB"
        echo "✅ Mobile app should download: $RELEASE_FILENAME"
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        
    - name: 🗑️ Delete feat/update branch
      run: |
        echo "🗑️ Deleting feat/update branch"
        git push origin --delete feat/update
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}